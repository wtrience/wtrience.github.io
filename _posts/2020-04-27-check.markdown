---
layout:     post
title:      "随笔整理01"
subtitle:   " \"coding everyday\""
date:       2019-12-13 12:00:00
author:     "Tian"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++
---
> “Thinking”

#并发编程的3个特性
1、原子性
2、可见性
3、有序性

#程序的编译、链接、装载与运行

编译器的工作过程
作者： 阮一峰

日期： 2014年11月11日

感谢 腾讯课堂NEXT学院 赞助本站，腾讯官方的前端课程 免费试学。

腾讯课堂 NEXT 学院

源码要运行，必须先转成二进制的机器码。这是编译器的任务。

比如，下面这段源码（假定文件名叫做test.c）。


#include <stdio.h>

int main(void)
{
  fputs("Hello, world!\n", stdout);
  return 0;
}
要先用编译器处理一下，才能运行。


$ gcc test.c
$ ./a.out
Hello, world!
对于复杂的项目，编译过程还必须分成三步。


$ ./configure
$ make  
$ make install
这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。

本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。



第一步 配置（configure）
编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做"配置"（configure）。

这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。

configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。


$ ./configure --prefix=/www --with-mysql
上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。

第二步 确定标准库和头文件的位置
源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。

编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。

第三步 确定依赖关系
对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。

（1）只有在B文件编译完成后，才开始编译A文件。

（2）当B文件发生变化时，A文件会被重新编译。

编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。

在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。

第四步 头文件的预编译（precompilation）
不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。

不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。

第五步 预处理（Preprocessing）
预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。


extern int fputs(const char *, FILE *);
extern FILE *stdout;

int main(void)
{
    fputs("Hello, world!\n", stdout);
    return 0;
}
为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。

这一步称为"预处理"（Preprocessing），因为完成之后，就要开始真正的处理了。

第六步 编译（Compilation）
预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。

下面是本文开头的那段源码转成的汇编码。


    .file   "test.c"
    .section    .rodata
.LC0:
    .string "Hello, world!\n"
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    movq    stdout(%rip), %rax
    movq    %rax, %rcx
    movl    $14, %edx
    movl    $1, %esi
    movl    $.LC0, %edi
    call    fwrite
    movl    $0, %eax
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  "GCC: (Debian 4.9.1-19) 4.9.1"
    .section    .note.GNU-stack,"",@progbits
这种转码后的文件称为对象文件（object file）。

第七步 连接（Linking）
对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。

编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。

make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。

第八步 安装（Installation）
上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。

表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为"安装"（Installation）。

第九步 操作系统连接
可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。

这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在/usr/share/applications目录下的.desktop文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。

这些事情就叫做"操作系统连接"。make install命令，就用来完成"安装"和"操作系统连接"这两步。

第十步 生成安装包
写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。

所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。

第十一步 动态连接（Dynamic linking）
正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。

前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。

现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。

（文章完）

.obj, .lib, .dll, .exe的关系（附：lib和DLL的区别）
时间  2016-03-02
标签 .obj .lib .dll .exe的关系 附lib和DLL的区别 栏目 Windows
原文   http://blog.csdn.net/caojunhao123/article/details/50778556

 
lib是和dll对应的。   
  lib是静态的库文件，dll是动态的库文件。   
  所谓静态就是link的时候把里面需要的东西抽取出来安排到你的exe文件中，以后运行   
  你的exe的时候不再需要lib。   
  所谓动态就是exe运行的时候依赖于dll里面提供的功能，没有这个dll，你的exe无法运   
  行。   
    
  lib,   dll,   exe都算是最终的目标文件，是最终产物。而c/c++属于源代码。源代码和最终   
  目标文件中过渡的就是中间代码obj，实际上之所以需要中间代码，是你不可能一次得到目   
  标文件。比如说一个exe需要很多的cpp文件生成。而编译器一次只能编译一个cpp文件。这   
  样编译器编译好一个cpp以后会将其编译成obj，当所有必须要的cpp都编译成obj以后，再统   
  一link成所需要的exe，应该说缺少任意一个obj都会导致exe的链接失败。

1.obj里存的是编译后的代码跟数据，并且有名称，所以在连接时会出现未解决的外部符号一说。当连成exe后便不存在名称的概念了，只有地址。lib就是一堆obj的组合。   
  2.理论上可以，但实际中通常用lib。   
  3.编译器会默认链接一些常用的库，其它的需要你自己指定。

附上lib和DLL的区别

(1)lib是编译时需要的，dll是运行时需要的。  如果要完成源代码的编译，有lib就够了。  如果也使动态连接的程序运行起来，有dll就够了。  在开发和调试阶段，当然最好都有。  (2)一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。  (3)在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。


http://www.voidcn.com/article/p-nrfrucny-o.html
https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/

https://tech.meituan.com/2015/01/22/linker.html

https://www.cnblogs.com/skynet/p/3372855.html

#DB主从一致性解决方法
1、半同步复制
主从不一致的原因是延时引起的,所以要消除这个延时的影响，可以从主库进行CUD操作时进行规避，办法就是等主从同步完成之后，主库上的写请求再返回，就是大家常说的“半同步复制”semi-sync。

请求            主库        从库
    CUD操作开始     
                      同步
                    同步完成
    CUD操作完成
请求            主库        从库

方案优点：利用数据库原生功能，比较简单
方案缺点：主库的写请求时延会增长，吞吐量会降低
2、数据库中间件
CUD操作

请求    中间件  主库    从库

    CUD操作 
            路由
                    同步

请求    中间件  主库    从库

R操作

请求    中间件  主库    从库

    R操作
            同步未完成
                    同步完成

请求    中间件  主库    从库

方案优点：能保证绝对一致
方案缺点：数据库中间件的成本比较高
3、缓存记录写key法
CUD操作
（1）将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms
（2）修改数据库

R操作
（1）先到cache里查看，对应库的对应key有没有相关数据
（2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据
（3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离

方案优点：相对数据库中间件，成本较低
方案缺点：方案缺点：为了保证“一致性”，引入了一个cache组件，并且读写数据库时都多了一步cache操作